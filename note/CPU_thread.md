## 📄 プロジェクト「Ethernet リバー」性能改善提案書（客観的報告版）

### 対象ノード: マシン 1（パケット解析: Raspberry Pi 4B）

---

## 1. 現状の機能確認と性能課題の概要

### 1.1 機能確認

プロジェクトの核となるパケットキャプチャ、解析、および OSC 送信（マシン 1）のアーキテクチャは実装されており、PyShark を使用し、特定の設計原則（`get_nested_attr`の採用など）に基づいて動作しています。

### 1.2 性能課題の概要

パケット解析ノード（Raspberry Pi 4B）上で実行中の Python プロセス（`main.py`）は、負荷テストにおいて CPU 使用率が**継続的に 100%を超える飽和状態**にあります（例: 103%）。

このシングルコア性能の完全な占有は、以下の結果を招いています。

-   **処理遅延（レイテンシ）の発生**: パケットのキャプチャ完了から OSC データ送信までの間に遅延が発生しており、リアルタイム可視化という**プロジェクトの要求仕様を満たす上での課題**となっています。
-   **性能維持の不安定性**: 適切な冷却がない場合、サーマルスロットリングによりプロセッサのクロック周波数が低下し、処理速度がさらに低下するリスクがあります。

---

## 2. プロファイリングに基づくボトルネックの詳細分析

プロファイリング結果（`profile_data.prof`の`tottime`、すなわち純粋な CPU 消費時間）を分析した結果、CPU 時間の大部分が**PyShark ライブラリの内部処理**と、それに伴う**Python 組み込みの文字列操作**に消費されていることが確認されました。

### 2.1 CPU 時間消費の構造的内訳

以下の表は、合計実行時間（累積時間）のうち、最も多くの純粋な CPU 時間を消費している上位の処理です。

| 順位  | tottime (秒) | 呼び出し回数（概算） | 処理内容 (ファイル:関数)               | 発生源/評価                                                 |
| :---- | :----------- | :------------------- | :------------------------------------- | :---------------------------------------------------------- |
| **1** | **97.75**    | 2,812 万回           | `xml_layer.py:_sanitize_field_name`    | PyShark（XML 層）。フィールド名の正規化処理。               |
| **2** | **85.35**    | 7.8 万回             | `str.translate`                        | Python 組み込み。文字列変換のコア処理。                     |
| **3** | **60.94**    | 7.8 万回             | `tshark_xml.py:packet_from_xml_packet` | PyShark（XML 層）。XML データからオブジェクトへの変換処理。 |
| **4** | **50.91**    | 8,454 万回           | `str.replace`                          | Python 組み込み。文字列置換のコア処理。                     |
| **5** | **30.32**    | 170 万回             | `xml_layer.py:get_field`               | PyShark（XML 層）。フィールドのルックアップ処理。           |
| **6** | **10.63**    | 7.8 万回             | `datetime.strftime`                    | Python 組み込み。タイムスタンプの文字列フォーマット。       |

### 2.2 ボトルネックの構造的評価

1.  **非効率な文字列操作の連鎖（最大の負荷要因）**:

    -   CPU 負荷の**約 9 割**が、上位 5 つの処理、特に**文字列の操作**（`str.replace`、`str.translate`、`str.lower`など）に集中しています。
    -   `_sanitize_field_name` (ランキング 1 位) は、フィールド名（例: `eth.src`）を Python 属性名（例: `eth_src`）に変換するために、複数の`str.replace`を内部で呼び出しています。
    -   **構造的な問題**: プロジェクトの設計で`utils.get_nested_attr()`が使用されている結果、PyShark の XML 層が**パケット内の全フィールド**に対してこの非効率な`_sanitize_field_name`を**数千万回**も繰り返すこととなり、Raspberry Pi 4B のシングルコア性能を完全に消費しています。

2.  **XML パースのオーバーヘッド**:

    -   ランキング 3 位の`packet_from_xml_packet`は、Tshark が出力した XML データ（冗長なタグ構造）を Python のオブジェクトに変換する処理であり、その負荷が`str.translate`（ランキング 2 位）のような低レベルな処理を呼び出す形で顕在化しています。

3.  **不必要な文字列変換**:
    -   `datetime.strftime`（ランキング 6 位）の処理も、パケット数（約 7.8 万回）に比例して約 10 秒の CPU 時間を消費しており、リアルタイム処理の負荷として無視できません。

## 3. 対策案と実施計画

課題を解消し、プロジェクトの要求水準を満たすリアルタイム性を確保するため、以下の対策を優先度順に実施することを提案します。

### 3.1 対策 I: パース形式の変更（最優先かつ根本解決）

**目標**: CPU 負荷の大部分を占める XML パースと文字列サニタイズ処理を回避する。

| 対策内容                       | 実行ファイル        | 期待される効果                                                                                                                   |
| :----------------------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------- |
| **EK JSON モードへの切り替え** | `eth-river/main.py` | 非効率な XML 層のロジックが回避され、高速な**JSON ベースの辞書アクセス**に移行する。これにより、CPU 負荷が**大幅に低減**します。 |

**具体的な修正**:
`FileCapture`または`LiveCapture`のインスタンス化時に、**`use_ek=True`**オプションを追加します。

### 3.2 対策 II: 処理ロジックの最適化と並列化（安定性向上）

フェーズ I の実施後、更なる性能余裕の確保および最適化を進めます。

1.  **時刻フォーマットの遅延**:
    -   `datetime.strftime`による負荷（ランキング 6 位）を避けるため、パケット処理パイプライン内では**Unix タイムスタンプ（数値）**のままデータを扱います。文字列フォーマットは、OSC 送信の直前でのみ実行するように修正します。
2.  **マルチプロセス化の検討**:
    -   `link_layer.process()`の実行を**`concurrent.futures.ProcessPoolExecutor`**などで並列化し、Raspberry Pi 4B の**4 つのコア**全てを活用する設計を導入します。これにより、パケット処理の**実効速度を向上**させ、リアルタイム性を確保します。
3.  **ハードウェア冷却の確保**:
    -   ソフトウェア最適化の性能を持続させるため、Raspberry Pi 4B に**アクティブ冷却（ファン）**が装備され、適切に動作していることを継続的に確認してください。

### 4. 実施手順（ロードマップ）

1.  **フェーズ I（最優先）**: `main.py`に**`use_ek=True`オプションを導入**し、CPU 負荷の劇的な改善（目標 CPU 使用率 50%以下）を確認する。
2.  **フェーズ II（順次実施）**: 時刻フォーマットの見直し、およびマルチプロセス化の検討・実装に進む。
3.  **検証**: 最終的に、描画ノード（マシン 3）側でパケット到着の遅延がないことを測定し、リアルタイム性が確保されたことを検証する。
