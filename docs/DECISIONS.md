# 重要な意思決定ログ (Important Design Decisions)

このファイルには、プロジェクトの設計、技術選定、および重要な仕様変更に関する意思決定とその背景が時系列で記録される。

もし時間がなく、たった一行しか書けないとしても、決定事項と**決定理由（Why）**だけは必ず残してください。

---

## [日付] - [決定事項を簡潔に示すタイトル]

**決定日:** YYYY-MM-DD
**関連チケット/PR:** (例: #1234, JIRA-5678)
**決定者/担当者:** (氏名または GitHub/Slack ID)

### 1. 背景 (Context / Problem)

### 2. 検討された代替案 (Alternatives Considered)

### 3. 決定 (Decision)

### 4. 決定理由 (Rationale)

### 5. 影響と結果 (Consequences)

---

---

## [2025-11-18] - [Pure ACK の明記と処理分岐]

**決定日:** 2025-11-18
**決定者/担当者:** noah-devtech

### 1. 背景 (Context / Problem)

TCP パケット解析において、単なる ACK（確認応答）をデータとして処理すべきか、それとも純粋な信頼性維持のための制御パケットとして区別すべきかという課題が存在していました。従来の処理では、ACK フラグが立っているパケットは全て一律に扱われていましたが、ペイロードが 0 の Pure ACK は、アプリケーション層の挙動ではなくネットワーク層（TCP）の信頼性維持のみに関わるため、後の分析やログのノイズとなる可能性が指摘されていました。

### 2. 検討された代替案 (Alternatives Considered)

| 代替案                                             | 説明                                                                                                                                                         | メリット                                                       | デメリット/批判的観点                                                                                                                                              |
| :------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| A. 現状維持                                        | ACK フラグがあれば、ペイロードの有無に関わらず一律に同じ処理を行う。                                                                                         | 実装が最も単純で、既存コードへの影響がない。                   | Pure ACK が誤って「データ」として認識され続け、分析結果のノイズ源となる。TCP の制御オーバーヘッドの正確な測定が困難。                                              |
| B. ペイロード長分岐                                | ペイロード長が 0 バイトのパケットを検知し、別のロジック（例：ログ出力しない）に分岐させる。                                                                  | 実装が比較的容易で、Pure ACK のみを分離できる。                | 厳密には Pure ACK（ACK フラグのみ）ではない他の 0 バイトパケット（例：FIN/ACK でデータなし）も除外されてしまう可能性がある。「Pure ACK」という概念の明確化が不足。 |
| C. フラグとペイロード長による厳密な分岐 (今回決定) | ACK フラグがセットされており、かつ SYN, FIN, RST フラグが全てクリアで、ペイロード長が 0 のパケットを「Pure ACK」として明記し、特別なロジックで分岐処理する。 | TCP の信頼性維持の挙動のみを捉えるため、分析の精度が向上する。 | 処理の分岐条件が複雑化し、わずかな実装コストが増加する。                                                                                                           |

### 3. 決定 (Decision)

代替案 C を採用し、以下の厳密な条件を満たすパケットを「Pure ACK」として定義し、分析処理を分岐させる。

### 4. 決定理由 (Rationale)

-   正確性の追求: Pure ACK（信頼性維持のための単なる確認応答）と、データ転送や接続制御を含む ACK（例：Piggybacked ACK、FIN/ACK）を明確に区別することが、パケット分析の質を高めるために不可欠であると判断した。
-   実務との整合性: 「Pure ACK」という実務で通用する用語を明確に定義に組み込むことで、現場のエンジニア間のコミュニケーションと、解析結果の解釈の一貫性を確保する。

### 5. 影響と結果 (Consequences)

| 領域          | 影響/結果                                                                                                                          | 備考（批判的評価）                                                                                                                            |
| :------------ | :--------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |
| 開発/実装     | パケット処理ロジックに分岐が追加されるため、コードの複雑性がわずかに増加する。                                                     | 分岐条件のテスト（SYN=0, FIN=0, RST=0, ACK=1, Len=0 のパターン）を厳格に行う必要がある。                                                      |
| 分析/ロギング | Pure ACK のログ出力レベルを調整したり、集計から除外したりすることが可能になり、分析結果の精度が向上する。                          | Pure ACK の存在自体はネットワーク負荷であることに変わりはないため、完全に無視するのではなく、別のメトリクスとして集計対象とするか検討が必要。 |
| 性能/効率     | 処理分岐が増えることによる解析処理の微細なオーバーヘッドの増加は考えられるが、得られる分析精度の向上により相殺されると見込まれる。 | 今後、TCP ウィンドウサイズ変更のみを目的としたデータのない ACK など、より複雑な制御パケットの処理も追加で考慮する必要が出てくる可能性がある。 |

---

---

## [2025-11-18] - [Unix タイムスタンプの精度をマイクロ秒（6 桁）に統一]

**決定日:** 2025-11-18
**決定者/担当者:** noah-devtech

### 1. 背景 (Context / Problem)

ネットワーク監視ログ（パケットキャプチャデータ）の解析において、ミリ秒（3 桁）以下の極めて短い時間差が頻繁に発生していることが判明した（*test-pcapng*では最小間隔は 74 ナノ秒）。従来の標準的なタイムスタンプ形式（秒またはミリ秒精度）では、これらの微細な時間差が切り捨てられ、「0 秒」や「0 ミリ秒」と記録されてしまう。これにより、高負荷時の正確な遅延（レイテンシ）やジッター（揺らぎ）の計測、およびイベントの正確な順序性の把握が困難であるという問題が発生した。

---

### 2. 検討された代替案 (Alternatives Considered)

-   代替案 A: 秒単位（0 桁）
    -   利点: データ量が最小になり、処理が非常に軽い。標準的な Unix タイム形式。
    -   欠点: ネットワーク監視に必要なすべての時間情報（レイテンシ、パケット間隔）が失われ、監視目的として不適。
-   代替案 B: ミリ秒単位（3 桁）
    -   利点: 一般的なログ処理との互換性が高く、扱いやすい。
    -   欠点: 74 ナノ秒のような極小の時間差を区別できず、監視ログの解像度が不十分となる。
-   代替案 C: ナノ秒単位（9 桁）
    -   利点: 最高レベルの精度を保証できる。
    -   欠点: 多くのデータベースや処理系で浮動小数点のデータ型サイズが大きくなり、データ量と処理負荷が不必要に増加する。

---

### 3. 決定 (Decision)

Unix タイムスタンプの丸め処理は、小数点以下 6 桁（マイクロ秒：$\mathbf{\mu\text{s}}$ 精度）に統一する。
現在（21 世紀の大部分）の Unix 時間は通常は 10 行であるため String 型では$10+1+6=17$桁に統一することにする。

---

### 4. 決定理由 (Rationale)

1.  必要な精度を確保: ログで確認された最小間隔（74 ナノ秒）は、マイクロ秒の範囲（$0.000074$秒）で正確に表現できる。これにより、パケット間の正確な時間差を計測し、高精度なパフォーマンス分析が可能となる。
2.  実用的なデータ量: 9 桁（ナノ秒）まで保持するのに比べ、6 桁に留めることで、ストレージ容量とデータ処理の負荷を実用的な範囲に抑えられる。
3.  高精度な分析: ネットワーク監視で最も重要な指標であるレイテンシ（遅延）やジッター（遅延の変動）を、ミリ秒よりも 1,000 倍高い解像度で把握できるようになる。

---

### 5. 影響と結果 (Consequences)

-   ポジティブな影響:
    -   ネットワークのボトルネックや高負荷時のパフォーマンス低下を、より正確かつ迅速に特定できるようになる。
    -   パケットの順序が厳密に保証され、トラブルシューティングの効率が向上する。
-   ネガティブな影響:
    -   従来の秒またはミリ秒精度で運用されているシステムと連携する際、フォーマット変換が必要になる場合がある。
    -   データ量（ストレージ要件）は、3 桁精度の場合に比べてわずかに増加する。

---
