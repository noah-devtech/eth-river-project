# プロジェクト「Ethernet リバー」引き継ぎ用サマリー

## 1. プロジェクトの目的とゴール

-   **目的**: ネットワークを流れる目に見えないデータパケットを、リアルタイムで可視化するインタラクティブなインスタレーション「Ethernet リバー」を制作する。
-   **ゴール**:
    -   **リアルタイム可視化**: 来場者が専用 Wi-Fi に接続すると、その通信（HTTP, HTTPS, DNS, QUIC など）が「光の川」の粒子として床や机に投影される。
    -   **タンジブル・インタラクション**: 来場者が物理的な「石」（タンジブル・オブジェクト）を置くと、Kinect（深度カメラ）がそれを認識し、川の流れ（パケットの流れ）に「介入」（せき止める、引き寄せるなど）できるようにする。
    -   **教育・体験**: 通信の「方向性」（上り/下り）や、通信の種類（プロトコル）、接続の開始と終了（ハンドシェイク）を視覚化することで、インターネットの裏側の仕組みを直感的に体験・理解してもらう。

---

## 2. 主要な技術スタック

-   **アーキテクチャ**: 3 台の Raspberry Pi による分散処理構成。
    -   **マシン 1 (パケット解析)**: Raspberry Pi 4B
    -   **マシン 2 (認識)**: Raspberry Pi 4B
    -   **マシン 3 (描画・シミュレーション)**: Raspberry Pi 5
-   **通信プロトコル**:
    -   **OSC (Open Sound Control)**: マシン 1 → マシン 3 (パケット情報)、マシン 2 → マシン 3 (Kinect 情報) の通信に使用。

### マシン 1: パケット解析 (Pi 4B)

-   **OS/構成**: 透過型 L2 ブリッジ（`br0`）として動作。IP アドレスは持たない。
-   **管理 I/F**: 内蔵 Wi-Fi (`wlan0`) 経由で SSH 接続および OSC 送信を行う。
-   **ソフトウェア**:
    -   **Python**: メインの処理言語。
    -   **`pyshark`**: パケットキャプチャと解析。
    -   **`python-osc`**: OSC メッセージの送信。

### マシン 2: 認識 (Pi 4B)

-   **ハードウェア**: **Kinect** (深度カメラ)
-   **ソフトウェア**: （未着手だが、以下の利用を想定）
    -   C++ (openFrameworks) または Python
    -   `ofxKinect` / `ofxOpenCv` または Python の OpenCV / libfreenect

### マシン 3: 描画・シミュレーション (Pi 5)

-   **ソフトウェア**:
    -   **Java**
    -   **Processing**: ビジュアライゼーションのメインフレームワーク。
    -   **`oscP5`**: Processing での OSC 受信ライブラリ。

---

## 3. 現状の ToDo リストと進捗

### 完了済み (P0/P1)

-   **[マシン 1]** `pyshark`によるパケット解析パイプラインの構築。
-   **[マシン 1]** OSC 送信機能の実装（`utils.py` の `format_output` で OSC を送信）。
-   **[マシン 1]** `tls_handler` による SNI（ドメイン名）取得機能の実装。
-   **[マシン 3]** Processing での OSC 受信機能の実装（`oscEvent`）。
-   **[マシン 3]** パーティクルシステムの基本実装（レベル 1：上から下へ流れる）。
-   **[マシン 3]** 通信方向（上り/下り）に基づくパーティクル発生位置の変更（上下両方から発生）。
-   **[マシン 3]** ローカル IP 判定をハードコーディング (`localNetPrefix`) に変更。

### 未完了（次にやること）

| 優先度     | タスク                     | 担当                  | 詳細                                                                                                                 |
| :--------- | :------------------------- | :-------------------- | :------------------------------------------------------------------------------------------------------------------- |
| **P2-1**   | **TCP ハンドシェイク処理** | マシン 1 (pyshark)    | `tcp_handler.py` を修正し、SYN/FIN/RST パケットを識別して専用の OSC メッセージ（例: `/packet/tcp_syn`）を送信する。  |
| **P3-1**   | **QUIC プロトコルの実装**  | マシン 1 (pyshark)    | `quic_handler.py` を新規作成し、`udp_handler.py` の辞書に登録して、QUIC の SNI も取得できるようにする。              |
| **P2-II**  | **Kinect 環境構築**        | マシン 2 (Kinect)     | Kinect を Pi 4B に接続し、物体（石）や人物を認識して OSC を送信するプログラムの開発を開始する。                      |
| **P2-III** | **「介入」ロジック実装**   | マシン 3 (Processing) | マシン 2（Kinect）からの OSC を受信し、川の流れ（パーティクルの挙動）を変化させるロジックを `Main.java` に追加する。 |
| **P3-Sim** | **シミュレーション高度化** | マシン 3 (Processing) | パーティクルに加速度や反発力（Flocking）を導入し、川の動きをよりリッチにする。                                       |
| **P3-Vis** | **TCP 制御パケット可視化** | マシン 3 (Processing) | P2-1 で実装した `TCP-SYN` などを受信し、寿命が短い粒子として描画するロジックを `Main.java` に追加する。              |

---

## 4. これまでに決定した重要な仕様・設計

-   **`pyshark` の設定**:
    -   パーサーは `use_json=True` ではなく、**`use_json=False`**（デフォルトの XML/PDML）で動作させる（この設定で SNI 取得に成功したため）。
    -   TCP 再アセンブリは `override_prefs={'tcp.desegment_tcp_streams': 'TRUE'}` で有効化する。
-   **属性アクセス**:
    -   `pyshark` のパケットオブジェクトへのアクセスは、`get_nested_attr()` ユーティリティ関数で統一し、安全性（`None` チェック）と構文の統一性を確保する。
-   **SNI の取得パス**:
    -   **TLS (HTTPS)**: `get_nested_attr(packet.tls, "handshake_extensions_server_name")` で取得する。
    -   **QUIC**: （`quic_handler.py` 未実装だが）`get_nested_attr(packet.quic, "sni")` などを試行する。
-   **プロトコル振り分け**:
    -   `pyshark` が解析したレイヤー名 (`layer_name`) をキーとして、`tcp_handler.py` と `udp_handler.py` の `APPLICATION_HANDLERS` 辞書で振り分ける。
-   **ビジュアライゼーション**:
    -   **通信方向**: Processing 側 (`Main.java`) で、`srcIp` と `dstIp` が `localNetPrefix` に一致するかを判定し、「Upstream（下から上へ）」と「Downstream（上から下へ）」のパーティクルを生成する。
    -   **即時表示**: リクエスト/レスポンスの「待ち」は実装せず、キャプチャした瞬間に即時粒子を発生させる。

---

## 5. 現在抱えている課題や懸念点

-   **Processing のパフォーマンス**: Pi 5 で Processing (Java) を実行する際、P3 の高度な物理シミュレーション（多数のパーティクル同士の反発計算）や、Kinect からの大量の OSC データ処理が加わった場合に、パフォーマンス（フレームレート）が低下しないかという懸念がある。
-   **Kinect のセットアップ**: Kinect（マシン 2）側の開発が未着手であり、Pi 4B (ARM/Linux) 上での Kinect ドライバのセットアップや認識プログラムの開発がスムーズに進むかは未検証。
-   **`tcp_handler.py` の TODO**: `tcp_handler.py` には、TCP の「再送や並び替えの処理」という技術的な TODO が残っているが、リアルタイム可視化においてこれがどの程度影響するかは未検証。
-   **`dns_handler.py` の TODO**: `dns_handler.py` に、過去のデバッグ用 TODO（パケット 23, 30, 35 の確認）が残っている。
-   **`pyshark` の解析精度**: `pyshark`（tshark）が、`DATA` レイヤー や、`STUN` のような、まだハンドラを実装していないプロトコルを `Unsupported Protocol` として処理している。これらをどう扱うか（無視するか、専用ハンドラを作るか）の検討が残っている。
